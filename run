#!/bin/bash

debug() { echo -n "$@ - " >&2; date >&2; }
debug start

set -o pipefail -e

# Temp files
config="$(mktemp)"      # configuration
result="$(mktemp)"      # result json
compilation="$(mktemp)" # output of compilation
execution="$(mktemp)"   # output of execution
mkdir "/tmp/build"      # compilation directory

trap "rm -rf '$config' '$result' '$compilation' '$execution' '/tmp/build'" EXIT

# Saving the configuration from stdin
cat > "$config"

# Directories containing the test files and the judge repository
resources="$(jshon -e 'resources' -u < "$config")"
judge="$(jshon -e 'judge' -u < "$config")"
workdir="$(jshon -e 'workdir' -u < "$config")"
filename="$(jshon -e 'filename' -u < "$config")"

# time and memory limit with margins
time_limit="$(jshon -e 'time_limit' -u < "$config")"
time_limit="$(( time_limit - 10 ))"

memory_limit="$(jshon -e 'memory_limit' -u < "$config")"
memory_limit="$(( memory_limit * 9 / 10000 ))"

# Other configuration parameters.
allow_compilation_warnings="$(jshon -Q -e 'allow_compilation_warnings' -u < "$config" || echo 'true')"

############################## [ Helper functions ] ############################
# Import json helper functions.
source $judge/dodona-json

compilation_error_count() {
    echo "$1" | egrep -o "[0-9]+ errors?$" | sed "s/[^0-9]//g" || echo "0"
}

compilation_warning_count() {
    echo "$1" | egrep -o "[0-9]+ warnings?$" | sed "s/[^0-9]//g" || echo "0"
}

explain_compilation_error() {
    echo ""
}

parse_compilation_error() {
    dodona_start_context

    # Print the compilation message.
    dodona_start_testcase_code_message "$1"

    # Try to explain this compilation message, add it to the testcase if found.
    explanation=$(explain_compilation_error "$1")
    [[ "$explanation" == "" ]] || dodona_append_plain_message "$explanation"

    # Get the code annotation information and annotate the code.
    annotation_column=$(echo "$1" | grep -o "\s*\^" | wc -c)
    annotation_column=$((annotation_column - 2))
    annotation_row=$(echo "$1" | sed "s/^$filename:\([0-9]\+\):.*/\1/g")
    annotation_row=$((annotation_row - 1))
    annotation_is_error=$(echo "$1" | grep -c "^$filename:[0-9]\+: error" || true)

    if [[ "$explanation" == "" ]]; then
        annotation_text=$(echo -e "$1" | sed "s/.*: error://" | sed "s/.*: warning://" | head -n 1)
    else
        annotation_text="$explanation"
    fi

    if [[ "$annotation_is_error" == "1" ]]; then
        dodona_annotate_code_error "$annotation_row" "$annotation_column" "$annotation_text"
    else
        dodona_annotate_code_warning "$annotation_row" "$annotation_column" "$annotation_text"
    fi

    dodona_close_failed_testcase
    dodona_close_failed_context
}

parse_compilation_errors() {
    # arg1 raw compilation output

    # Processes the compilation errors, store them in an array, after which the
    # invidual errors/warnings are processed.
    compile_errs=()
    compile_err=""
    while IFS="\n" read -r line; do
        new_case=$(echo "$line" | egrep -c "^$filename:[0-9]+:" || true)

        if [[ "$new_case" == "0" || $compile_err == "" ]]; then
            compile_err+="$line\n"
            continue
        fi

        compile_errs+=("$compile_err")
        compile_err="$line\n"
    done <<< "$1"

    # Last error/warning will end with "x errors/y warnings; remove this part."
    compile_err=$(echo "$compile_err" | sed "s/[0-9]\+ warnings\?//g")
    compile_err=$(echo "$compile_err" | sed "s/[0-9]\+ errors\?//g")
    compile_errs+=("$compile_err")

    # The errors and warnings could not be processed in the previous while
    # loop due to problems with jshon/stdin and read.
    for i in "${compile_errs[@]}"; do
        parse_compilation_error "$i"
    done
}

compilation_error_in_submission() {
    compile_log=$(cat $1)

    # Parse the amount of compilation errors and warnings.
    compile_err_count=$(compilation_error_count "$compile_log")
    compile_warn_count=$(compilation_warning_count "$compile_log")
    compile_errwarn_sum="$((compile_err_count + compile_warn_count))"

    # Get the correct noun.
    [[ "$compile_err_count" == "1" ]] && compile_err_noun="fout" || compile_err_noun="fouten"
    [[ "$compile_warn_count" == "1" ]] && compile_warn_noun="waarschuwing" || compile_warn_noun="waarschuwingen"

    dodona_start_judgement
    dodona_start_tab "Compiler"
    dodona_append_plain_message "Je code kon niet worden gecompileerd en bijgevolg niet worden uitgevoerd. De compiler rapporteerde $compile_err_count $compile_err_noun en $compile_warn_count $compile_warn_noun."

    parse_compilation_errors "$compile_log"

    dodona_close_tab $compile_errwarn_sum
    dodona_close_judgement_compilation_error "$compile_err_count $compile_err_noun"
}

compilation_error_in_tests() {
    compile_log=$(cat $1)

    # Parse the amount of compilation errors and warnings.
    compile_err_count=$(compilation_error_count "$compile_log")
    compile_warn_count=$(compilation_warning_count "$compile_log")
    compile_errwarn_sum="$((compile_err_count + compile_warn_count))"

    # Get the correct noun.
    [[ "$compile_err_count" == "1" ]] && compile_err_noun="fout" || compile_err_noun="fouten"
    [[ "$compile_warn_count" == "1" ]] && compile_warn_noun="waarschuwing" || compile_warn_noun="waarschuwingen"

    # dodona_start_judgement
    # dodona_start_tab "Compiler"
    # dodona_append_plain_message "Je code kon niet worden gecompileerd en bijgevolg niet worden uitgevoerd. \
    # De compiler rapporteerde $compile_err_count $compile_err_noun en $compile_warn_count $compile_warn_noun."

    parse_compilation_errors "$compile_log"

    # dodona_close_tab $compile_errwarn_sum
    # dodona_close_judgement_compilation_error 'a'
}


################################# [ Start run ] ################################

# Record time
start_time="$(date +"%s")"

debug after init

# Compiling judge into "build" and getting a jar in the workdir
find "$judge/src" -name '*.java' \
    | xargs javac -classpath "$judge/lib/*:/tmp/build" -d /tmp/build -sourcepath "$judge/src"
jar -cf "judge.jar" -C /tmp/build .
testlibs="$(find "$judge/lib" "$resources" -name '*.jar' | xargs echo | tr ' ' ':')"
worklibs="$(find "$workdir" -name '*.jar' | xargs echo | tr ' ' ':')"

debug compiled judge

# Compiling the workdir given code
if ! find . -name '*.java' | xargs --no-run-if-empty javac -cp ".:${worklibs}:${testlibs}" -d . -sourcepath . > "$compilation" 2>&1; then
    compilation_error_in_tests <(sed 's_.*/\([^/]*.java\)_\1_' "$compilation")
    exit 0
fi

debug compiled workdir

# Create the Input.java class, containing the submitted code
cat "$(jshon -e 'source' -u < "$config")" > "$filename"

# Compiling the user code
compile_opts="-Xlint:all"
[ "$allow_compilation_warnings" == 'true' ] || compile_opts+=' -Werror'

if ! javac -cp ".:${worklibs}" ${compile_opts} "$filename" > "$compilation" 2>&1; then
    compilation_error_in_submission "$compilation"
    exit 0
fi

debug compiled user code

# Compiling the tests
if ! find "$resources" -name '*.java' | xargs javac -cp ".:${resources}:${worklibs}:${testlibs}:judge.jar" -d . -sourcepath "$resources" > "$compilation" 2>&1; then
    compilation_error_in_tests <(sed 's_.*/\([^/]*.java\)_\1_' "$compilation")
    exit 0
fi

debug compiled tests

# Record time
compiled_time="$(date +"%s")"
compilation_time="$((compiled_time - start_time))"

# Running the tests
timeout --preserve-status "$((time_limit - compilation_time))" java -Xmx"${memory_limit}k" -cp ".:${worklibs}:${testlibs}:judge.jar" dodona.junit.JUnitJSON

debug finished
